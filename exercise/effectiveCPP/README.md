# 习惯c++

## 条款02 - 使用const,enums,template inline代替define

- 以const代替#define，一是可以提高编译时报错定位效率，二是define并不重视作用域，尤其是类内的变量。
- 使用template inline 去代替使用宏定义的函数。

## 条款03 - 尽可能使用const

- const默认作用于左边的东西，否则作用于其右边的东西。
- 令某个函数返回const，可以降低使用这个函数发生错误的可能性，比如operator*操作返回const，可以避免出现右值被使用的情况。
- 利用常量性不同进行重载，同时可以通过两次类型转换，使得non-const版本调用const版本，减少代码重复。

## 条款04 - 确定对象在被使用前已先被初始化

- 构造函数需要使用成员初值列进行初始化，而不是在构造函数内部进行赋值操作，后者会先调用各个成员变量的默认构造函数，再进行拷贝赋值。另外使用成员初值列还能避免很多其他潜在的问题，包括const或者references这种一定需要初值的类型。
- 手工初始化内置类型
- 使用local static 对象替换non-local static对象，就是单件模式。。。

# 构造/析构/赋值运算

## 条款05 - 了解c++默默编写并调用哪些函数

- 一共4个，copy构造函数，copy assignment 操作符，析构函数，另外在没有声明任何构造函数的情况下会生成默认构造函数。
- c++不允许“让reference改指向不同的对象”和“const成员不可更改”，所以对于类内含有reference和const成员的情况，编译器不会生成copy assignment.
- 基类的copy assignment是私有的话，编译器也不会为派生类生成copy assignment.

## 条款06 - 若不想使用编译器自动生成的函数，就该明确拒绝

- 使用privete的copy assignment和copy构造函数，避免被拷贝
- 继承uncopyable类，改积累实现了private的拷贝相关构造函数，且该类的析构函数不一定要是虚函数。
- 使用delete（原书是03版本，还没有delete）

## 条款07 - 为多态基类声明virtual析构函数

- 如题目所示，只有用于多态的基类，才需要将析构函数声明为virtual
- 如果类内有virtual函数，那么他必然要有virtual析构函数（原文是几乎确定有）。
- 不要去继承没有virtual析构函数的类，其实这一点也挺重要的，意味着==不要去继承stl容器之类的类==。
- 也不要为所有的类去声明一个virtual析构函数，因为virtual函数会带来虚表，从而带来更大的占用。
- ==纯虚函数也是可以提供定义的！！== 为什么要这么做，文中说有时候需要一个抽象class（啥情况啊。。。）

## 条款08 - 别让异常逃离析构函数

- 析构函数绝对不要吐出异常，因为若是有多个对象析构，会可能存在多个异常，而只要有两个异常同时存在，程序如果不结束运行就会有不明确行为。
- 如果一个析构函数调用的函数可能会抛出异常，析构函数应该捕获这个异常，然后吞下他们或者直接结束程序std::abort()【实际上这里说的就是用try catch做处理嘛...】
- 给用户提供一个可以处理异常函数的接口，同时封装的类的析构函数也调用这个接口。

## 条款09 - 绝不在构造和析构过程中调用virtual函数

- 如果在构造函数内调用虚函数，那么派生类在构造时，实际调用的会是基类的虚函数，这一行为有点违反认知。编译器可能会报警，也可能不会，但是如果有多层嵌套，编译器大部分时候不会报警。
- 那如果有类似创建时记录当前类的信息的需求改怎么做？由派生类的构造函数传递信息给基类，去做记录。

## 条款10 - 令operator=返回一个reference *this

- 所有和operator=相关的操作都应该返回reference *this，可以满足连锁赋值。（这是一个协议，标准库也都是这样做的）

## 条款11 - 在operator= 中处理“自我赋值”

- 这件事是这样的，对于一个需要自己进行资源管理的类，在进行赋值拷贝时，需要删除自身所占内存如:
    ```C++
    Wigdet& Wigdet::operator=(const Wigdet &rhs){
        delete pb;
        pb = new Bitmap(*rhs.pb);
        return *this;
    }
    ```
    但是这种做法会导致自我赋值的时候出现删除自身的情况，所以通常需要在最前面加上证同测试：
    ```C++
    if(this == &rhs) return *this;
    ```
    但是这时候还有个异常安全性的问题，new的时候如果空间不够，会抛出异常，导致没有拷贝成功的情况下删除了自身。不过有个好事是，如果我们考虑了异常安全性，可以同时避免自我拷贝安全性：
    ```C++
    Widget& Widget::operator=(const Widget &rhs){
        Bitmap* pOrig = pb;
        pb = new Bitmap(*rhs.pb);
        delete pOrig;
        return *this;
    }
    ```
    但是这个时候又有问题了。。。自我拷贝的时候效率不高，可以加上证同测试，但是加上证同测试会导致非自我拷贝时多一个循环判断，会影响很多的指令集判断，降低效率。所以是否要加证同测试，取决于业务实际情况。。
- 除了上面一套。。还可以使用copy and swap技术，具体见条款29吧。

## 条款12 复制对象时勿忘其每一个成分

- 派生类的拷贝函数不仅需要拷贝派生类自己的成员变量，还需要调用父类的拷贝函数来对父类的成员变量进行赋值。（否则基类自身会调用构造函数进行构造。）
- 同一个类不要用一个copy函数调用另一个copy函数。